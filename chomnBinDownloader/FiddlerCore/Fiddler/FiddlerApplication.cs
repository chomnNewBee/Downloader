using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net.Security;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using FiddlerCore.Analytics;
using FiddlerCore.PlatformExtensions;
using FiddlerCore.PlatformExtensions.API;
using FiddlerCore.SazProvider;
using FiddlerCore.Utilities;
using FiddlerCore.Utilities.SmartAssembly.Attributes;
using Telerik.NetworkConnections;

namespace Fiddler;

/// <summary>
/// This class acts as the central point for script/extensions to interact with Fiddler components.
/// </summary>
public static class FiddlerApplication
{
	/// <summary>
	/// TRUE if Fiddler is currently shutting down. Suspend all work that won't have side-effects.
	/// </summary>
	public static bool isClosing;

	[DoNotObfuscate]
	internal static IAnalytics oTelemetry;

	/// <summary>
	/// The default certificate used for client authentication
	/// </summary>
	public static X509Certificate oDefaultClientCertificate;

	public static LocalCertificateSelectionCallback ClientCertificateProvider;

	private static ISAZProvider sazProvider;

	internal static readonly Logger _Log;

	/// <summary>
	/// Fiddler's "Janitor" clears up unneeded resources (e.g. server sockets, DNS entries)
	/// </summary>
	internal static readonly PeriodicWorker Janitor;

	/// <summary>
	/// Fiddler's core proxy object.
	/// </summary>
	[CodeDescription("Fiddler's core proxy engine.")]
	public static Proxy oProxy;

	/// <summary>
	/// Fiddler Import/Export Transcoders
	/// </summary>
	public static FiddlerTranscoders oTranscoders;

	/// <summary>
	/// List of "leaked" temporary files to be deleted as Fiddler exits.
	/// </summary>
	private static readonly List<string> slLeakedFiles;

	/// <summary>
	/// Process ID of this Fiddler instance
	/// </summary>
	internal static readonly int iPID;

	/// <summary>
	/// processname:PID of Fiddler
	/// </summary>
	internal static readonly string sProcessInfo;

	private static IPlatformExtensions platformExtensions;

	public static ISAZProvider oSAZProvider
	{
		get
		{
			return sazProvider;
		}
		set
		{
			sazProvider = value;
		}
	}

	/// <summary>
	/// Fiddler's logging system
	/// </summary>
	[CodeDescription("Fiddler's logging subsystem; displayed on the LOG tab by default.")]
	public static Logger Log => _Log;

	/// <summary>
	/// Fiddler's Preferences collection. Learn more at http://fiddler.wikidot.com/prefs
	/// </summary>
	[CodeDescription("Fiddler's Preferences collection. http://fiddler.wikidot.com/prefs")]
	public static IFiddlerPreferences Prefs => CONFIG.RawPrefs;

	/// <summary>
	/// By setting this property you can provide Telerik Fiddler Core with custom MIME-type-to-file-extension mappings.
	/// </summary>
	public static IEnumerable<MimeMap> CustomMimeMappings
	{
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value", "CustomMimeMappings cannot be null");
			}
			MimeMappingsProvider.Instance.LoadCustomMimeMappings(Log, value);
		}
	}

	/// <summary>
	/// This event fires when the user instructs Fiddler to clear the cache or cookies
	/// </summary>
	[CodeDescription("This event fires when the user instructs Fiddler to clear the cache or cookies.")]
	public static event EventHandler<CacheClearEventArgs> OnClearCache;

	/// <summary>
	/// This event fires each time FiddlerCore reads data from network for the server's response. Note that this data
	/// is not formatted in any way, and must be parsed by the recipient.
	/// </summary>
	public static event EventHandler<RawReadEventArgs> OnReadResponseBuffer;

	/// <summary>
	/// This event fires each time FiddlerCore reads data from network for the client's request. Note that this data
	/// is not formatted in any way, and must be parsed by the recipient.
	/// </summary>
	public static event EventHandler<RawReadEventArgs> OnReadRequestBuffer;

	/// <summary>
	/// This event fires when a client request is received by Fiddler
	/// </summary>
	public static event SessionStateHandler BeforeRequest;

	/// <summary>
	/// This event fires when a server response is received by Fiddler
	/// </summary>
	public static event SessionStateHandler BeforeResponse;

	/// <summary>
	/// This event fires when Request Headers are available
	/// </summary>
	public static event SessionStateHandler RequestHeadersAvailable;

	/// <summary>
	/// This event fires when Response Headers are available
	/// </summary>
	public static event SessionStateHandler ResponseHeadersAvailable;

	/// <summary>
	/// This event fires when an error response is generated by Fiddler
	/// </summary>
	public static event SessionStateHandler BeforeReturningError;

	/// <summary>
	/// This event fires when Fiddler captures a WebSocket message
	/// </summary>
	public static event EventHandler<WebSocketMessageEventArgs> OnWebSocketMessage;

	/// <summary>
	/// This event fires when a session has been completed
	/// </summary>
	public static event SessionStateHandler AfterSessionComplete;

	/// <summary>
	/// This event fires when Fiddler evaluates the validity of a server-provided certificate. Adjust the value of the ValidityState property if desired.
	/// </summary>
	[CodeDescription("This event fires a HTTPS certificate is validated.")]
	public static event EventHandler<ValidateServerCertificateEventArgs> OnValidateServerCertificate;

	/// <summary>
	/// Sync this event to be notified when FiddlerCore has attached as the system proxy.")]
	/// </summary>
	[CodeDescription("Sync this event to be notified when FiddlerCore has attached as the system proxy.")]
	public static event SimpleEventHandler FiddlerAttach;

	/// <summary>
	/// Sync this event to be notified when FiddlerCore has detached as the system proxy.
	/// </summary>
	[CodeDescription("Sync this event to be notified when FiddlerCore has detached as the system proxy.")]
	public static event SimpleEventHandler FiddlerDetach;

	/// <summary>
	/// Fired each time Fiddler successfully establishes a TCP/IP connection
	/// </summary>
	public static event EventHandler<ConnectionEventArgs> AfterSocketConnect;

	/// <summary>
	/// Fired each time Fiddler successfully accepts a TCP/IP connection
	/// </summary>
	public static event EventHandler<ConnectionEventArgs> AfterSocketAccept;

	internal static void InitializeTelemetry()
	{
		oTelemetry = AnalyticsFactory.Instance.GetAnalytics();
		oTelemetry.Start();
	}

	/// <summary>
	/// Gets Fiddler* version info
	/// </summary>
	/// <returns>A string indicating the build/flavor of the Fiddler* assembly</returns>
	public static string GetVersionString()
	{
		FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location);
		string sExtraFeatures = string.Empty;
		string sSKU = "FiddlerCore";
		return $"{sSKU}/{fvi.FileMajorPart}.{fvi.FileMinorPart}.{fvi.FileBuildPart}.{fvi.FilePrivatePart}{sExtraFeatures}";
	}

	/// <summary>
	/// Set the DisplayName for the application
	/// </summary>
	/// <param name="sAppName">1 to 64 character name to be displayed in error messages, etc</param>
	public static void SetAppDisplayName(string sAppName)
	{
		if (string.IsNullOrEmpty(sAppName) || sAppName.Length > 64)
		{
			throw new ArgumentException("AppName must be 1 to 64 characters");
		}
	}

	/// <summary>
	/// Checks if FiddlerCore is running.
	/// </summary>
	/// <returns>TRUE if FiddlerCore is started/listening; FALSE otherwise.</returns>
	public static bool IsStarted()
	{
		return oProxy != null;
	}

	/// <summary>
	/// Checks if FiddlerCore is running and registered as the System Proxy.
	/// </summary>
	/// <returns>TRUE if FiddlerCore IsStarted AND registered as the system proxy; FALSE otherwise.</returns>
	public static bool IsSystemProxy()
	{
		return oProxy != null && oProxy.IsAttached;
	}

	/// <summary>
	/// Recommended way to Start FiddlerCore.
	/// </summary>
	/// <param name="startupSettings"><see cref="T:Fiddler.FiddlerCoreStartupSettings" /></param>
	public static void Startup(FiddlerCoreStartupSettings startupSettings)
	{
		if (oProxy != null)
		{
			throw new InvalidOperationException("Calling startup twice without calling shutdown is not permitted.");
		}
		TrackAnalyticsOnStartup();
		AttachToPlatformExtensionsEvents();
		CONFIG.ListenPort = startupSettings.ListenPort;
		CONFIG.bAllowRemoteConnections = startupSettings.AllowRemoteClients;
		CONFIG.DecryptHTTPS = startupSettings.DecryptSSL;
		CONFIG.bCaptureCONNECT = true;
		if (startupSettings.HookUsingPACFile)
		{
			Prefs.SetBoolPref("fiddler.proxy.pacfile.usefileprotocol", bValue: false);
			CONFIG.HookWithPAC = true;
		}
		if (startupSettings.OptimizeThreadPool)
		{
			int iProcCount = Environment.ProcessorCount;
			int iMinWorkerThreads = Math.Max(16, 6 * iProcCount);
			int iMinIOThreads = iProcCount;
			if (iMinWorkerThreads > 0 && iMinIOThreads > 0)
			{
				ThreadPool.SetMinThreads(iMinWorkerThreads, iMinIOThreads);
			}
		}
		CONFIG.CaptureFTP = startupSettings.CaptureFTP;
		if (startupSettings.CaptureLocalhostTraffic)
		{
			CONFIG.sHostsThatBypassFiddler = CONFIG.sHostsThatBypassFiddler;
		}
		CONFIG.HookAllConnections = startupSettings.MonitorAllConnections;
		if (startupSettings.UpstreamProxySettings != null)
		{
			CONFIG.UpstreamGateway = GatewayType.Manual;
			oProxy = new Proxy(isPrimary: true, startupSettings.UpstreamProxySettings);
			SetUpstreamGatewayPreferences(GetFormattedUpstreamGatewaySettings(startupSettings.UpstreamProxySettings), startupSettings.UpstreamProxySettings.BypassHosts);
			oProxy.CollectConnectoidAndGatewayInfo(shouldRefreshUpstreamGatewayInfo: false);
			if (oProxy.Start(CONFIG.ListenPort, CONFIG.bAllowRemoteConnections) && startupSettings.ListenPort == 0)
			{
				CONFIG.ListenPort = oProxy.ListenPort;
			}
			return;
		}
		if (startupSettings.ChainToUpstreamGateway)
		{
			CONFIG.UpstreamGateway = GatewayType.System;
		}
		else if (!string.IsNullOrEmpty(startupSettings.UpstreamGateway))
		{
			SetUpstreamGatewayPreferences(startupSettings.UpstreamGateway, startupSettings.UpstreamGatewayBypassList);
			CONFIG.UpstreamGateway = GatewayType.Manual;
		}
		else
		{
			CONFIG.UpstreamGateway = GatewayType.None;
		}
		oProxy = new Proxy(isPrimary: true, null);
		if (oProxy.Start(CONFIG.ListenPort, CONFIG.bAllowRemoteConnections))
		{
			if (startupSettings.ListenPort == 0)
			{
				CONFIG.ListenPort = oProxy.ListenPort;
			}
			if (startupSettings.RegisterAsSystemProxy)
			{
				oProxy.Attach(bCollectGWInfo: true);
			}
			else if (startupSettings.ChainToUpstreamGateway)
			{
				oProxy.CollectConnectoidAndGatewayInfo(shouldRefreshUpstreamGatewayInfo: true);
			}
			else
			{
				oProxy.RefreshUpstreamGatewayInformation();
			}
		}
	}

	private static void SetUpstreamGatewayPreferences(string upstreamGateway, string bypassList)
	{
		Prefs.SetStringPref("fiddler.network.gateway.proxies", upstreamGateway);
		Prefs.SetStringPref("fiddler.network.gateway.exceptions", bypassList);
	}

	private static string GetFormattedUpstreamGatewaySettings(ProxySettings proxySettings)
	{
		string upstreamGateway = string.Empty;
		if (proxySettings.HttpProxyEnabled)
		{
			upstreamGateway += $"http={proxySettings.HttpProxyHost}:{proxySettings.HttpProxyPort}";
		}
		if (proxySettings.HttpsProxyEnabled)
		{
			upstreamGateway += $";https={proxySettings.HttpsProxyHost}:{proxySettings.HttpsProxyPort}";
		}
		if (proxySettings.FtpProxyEnabled)
		{
			upstreamGateway += $";ftp={proxySettings.FtpProxyHost}:{proxySettings.FtpProxyPort}";
		}
		if (proxySettings.SocksProxyEnabled)
		{
			upstreamGateway += $";socks={proxySettings.SocksProxyHost}:{proxySettings.SocksProxyPort}";
		}
		return upstreamGateway;
	}

	/// <summary>
	/// Start a new proxy endpoint instance, listening on the specified port
	/// </summary>
	/// <param name="iPort">The port to listen on</param>
	/// <param name="bAllowRemote">TRUE if remote clients should be permitted to connect to this endpoint</param>
	/// <param name="sHTTPSHostname">A Hostname (e.g. EXAMPLE.com) if this endpoint should be treated as a HTTPS Server</param>
	/// <returns>A Proxy object, or null if unsuccessful</returns>
	public static Proxy CreateProxyEndpoint(int iPort, bool bAllowRemote, string sHTTPSHostname)
	{
		Proxy oNewProxy = new Proxy(isPrimary: false, null);
		if (!string.IsNullOrEmpty(sHTTPSHostname))
		{
			oNewProxy.ActAsHTTPSEndpointForHostname(sHTTPSHostname);
		}
		if (oNewProxy.Start(iPort, bAllowRemote))
		{
			return oNewProxy;
		}
		oNewProxy.Dispose();
		return null;
	}

	/// <summary>
	/// Start a new proxy endpoint instance, listening on the specified port
	/// </summary>
	/// <param name="iPort">The port to listen on</param>
	/// <param name="bAllowRemote">TRUE if remote clients should be permitted to connect to this endpoint</param>
	/// <param name="certHTTPS">A certificate to return when clients connect, or null</param>
	/// <returns>A Proxy object, or null if unsuccessful</returns>
	public static Proxy CreateProxyEndpoint(int iPort, bool bAllowRemote, X509Certificate2 certHTTPS)
	{
		Proxy oNewProxy = new Proxy(isPrimary: false, null);
		if (certHTTPS != null)
		{
			oNewProxy.AssignEndpointCertificate(certHTTPS);
		}
		if (oNewProxy.Start(iPort, bAllowRemote))
		{
			return oNewProxy;
		}
		oNewProxy.Dispose();
		return null;
	}

	/// <summary>
	/// Shuts down the FiddlerCore proxy and disposes it. Note: If there's any traffic in progress while you're calling this method,
	/// your background threads are likely to blow up with ObjectDisposedExceptions or NullReferenceExceptions. In many cases, you're
	/// better off simply calling oProxy.Detach() and letting the garbage collector clean up when your program exits.
	/// </summary>
	public static void Shutdown()
	{
		if (oProxy != null)
		{
			oProxy.Detach();
			oProxy.Dispose();
			oProxy = null;
			DetachFromPlatformExtensionsEvents();
		}
	}

	/// <summary>
	/// Notify a listener that a block of a response was read.
	/// </summary>
	/// <param name="oS">The session for which the response is being read</param>
	/// <param name="arrBytes">byte buffer (not completely full)</param>
	/// <param name="cBytes">bytes set.</param>
	/// <returns>FALSE if AbortReading was set</returns>
	internal static bool DoReadResponseBuffer(Session oS, byte[] arrBytes, int cBytes)
	{
		if (FiddlerApplication.OnReadResponseBuffer == null)
		{
			return true;
		}
		if (oS.isFlagSet(SessionFlags.Ignored))
		{
			return true;
		}
		RawReadEventArgs oRREA = new RawReadEventArgs(oS, arrBytes, cBytes);
		FiddlerApplication.OnReadResponseBuffer(oS, oRREA);
		return !oRREA.AbortReading;
	}

	/// <summary>
	/// Notify a listener that a block of a request was read. Note that this event may fire with overlapping blocks of data but
	/// different sessions if the client uses HTTP Pipelining.
	/// </summary>
	/// <param name="oS">The session for which the response is being read</param>
	/// <param name="arrBytes">byte buffer (not completely full)</param>
	/// <param name="cBytes">bytes set.</param>
	/// <returns>FALSE if AbortReading was set</returns>
	internal static bool DoReadRequestBuffer(Session oS, byte[] arrBytes, int cBytes)
	{
		if (FiddlerApplication.OnReadRequestBuffer == null)
		{
			return true;
		}
		if (oS.isFlagSet(SessionFlags.Ignored))
		{
			return true;
		}
		RawReadEventArgs oRREA = new RawReadEventArgs(oS, arrBytes, cBytes);
		FiddlerApplication.OnReadRequestBuffer(oS, oRREA);
		return !oRREA.AbortReading;
	}

	internal static bool DoClearCache(bool bClearFiles, bool bClearCookies)
	{
		EventHandler<CacheClearEventArgs> oToNotify = FiddlerApplication.OnClearCache;
		if (oToNotify == null)
		{
			return true;
		}
		CacheClearEventArgs oCCEA = new CacheClearEventArgs(bClearFiles, bClearCookies);
		oToNotify(null, oCCEA);
		return !oCCEA.Cancel;
	}

	internal static void CheckOverrideCertificatePolicy(Session oS, string sExpectedCN, X509Certificate ServerCertificate, X509Chain ServerCertificateChain, SslPolicyErrors sslPolicyErrors, ref CertificateValidity oValidity)
	{
		EventHandler<ValidateServerCertificateEventArgs> oToNotify = FiddlerApplication.OnValidateServerCertificate;
		if (oToNotify != null)
		{
			ValidateServerCertificateEventArgs oEA = new ValidateServerCertificateEventArgs(oS, sExpectedCN, ServerCertificate, ServerCertificateChain, sslPolicyErrors);
			oToNotify(oS, oEA);
			oValidity = oEA.ValidityState;
		}
	}

	internal static void DoBeforeRequest(Session oSession)
	{
		if (!oSession.isFlagSet(SessionFlags.Ignored) && FiddlerApplication.BeforeRequest != null)
		{
			FiddlerApplication.BeforeRequest(oSession);
		}
	}

	internal static void DoBeforeResponse(Session oSession)
	{
		if (!oSession.isFlagSet(SessionFlags.Ignored) && FiddlerApplication.BeforeResponse != null)
		{
			FiddlerApplication.BeforeResponse(oSession);
		}
	}

	internal static void DoResponseHeadersAvailable(Session oSession)
	{
		if (!oSession.isFlagSet(SessionFlags.Ignored) && FiddlerApplication.ResponseHeadersAvailable != null)
		{
			FiddlerApplication.ResponseHeadersAvailable(oSession);
		}
	}

	internal static void DoRequestHeadersAvailable(Session oSession)
	{
		if (!oSession.isFlagSet(SessionFlags.Ignored) && FiddlerApplication.RequestHeadersAvailable != null)
		{
			FiddlerApplication.RequestHeadersAvailable(oSession);
		}
	}

	internal static void DoOnWebSocketMessage(Session oS, WebSocketMessage oWSM)
	{
		if (!oS.isFlagSet(SessionFlags.Ignored))
		{
			FiddlerApplication.OnWebSocketMessage?.Invoke(oS, new WebSocketMessageEventArgs(oWSM));
		}
	}

	internal static void DoBeforeReturningError(Session oSession)
	{
		if (!oSession.isFlagSet(SessionFlags.Ignored) && FiddlerApplication.BeforeReturningError != null)
		{
			FiddlerApplication.BeforeReturningError(oSession);
		}
	}

	internal static void DoAfterSessionComplete(Session oSession)
	{
		if (!oSession.isFlagSet(SessionFlags.Ignored) && FiddlerApplication.AfterSessionComplete != null)
		{
			FiddlerApplication.AfterSessionComplete(oSession);
		}
	}

	internal static void OnFiddlerAttach()
	{
		if (FiddlerApplication.FiddlerAttach != null)
		{
			FiddlerApplication.FiddlerAttach();
		}
	}

	internal static void OnFiddlerDetach()
	{
		if (FiddlerApplication.FiddlerDetach != null)
		{
			FiddlerApplication.FiddlerDetach();
		}
	}

	/// <summary>
	/// Export Sessions in the specified format
	/// </summary>
	/// <param name="sExportFormat">Shortname of desired format</param>
	/// <param name="oSessions">Sessions to export</param>
	/// <param name="dictOptions">Options to pass to the ISessionExport interface</param>
	/// <param name="ehPCEA">Your callback event handler, or NULL to allow Fiddler to handle</param>
	/// <returns>TRUE if successful, FALSE if desired format doesn't exist or other error occurs</returns>
	public static bool DoExport(string sExportFormat, Session[] oSessions, Dictionary<string, object> dictOptions, EventHandler<ProgressCallbackEventArgs> ehPCEA)
	{
		if (string.IsNullOrEmpty(sExportFormat))
		{
			return false;
		}
		TranscoderTuple ttExport = oTranscoders.GetExporter(sExportFormat);
		if (ttExport == null)
		{
			Log.LogFormat("No exporter for the format '{0}' was available.", sExportFormat);
			return false;
		}
		bool bResult = false;
		try
		{
			ISessionExporter oseExporter = (ISessionExporter)Activator.CreateInstance(ttExport.typeFormatter);
			if (ehPCEA == null)
			{
				ehPCEA = delegate(object sender, ProgressCallbackEventArgs oPCE)
				{
					string text = ((oPCE.PercentComplete > 0) ? ("Export is " + oPCE.PercentComplete + "% complete; ") : string.Empty);
					Log.LogFormat("{0}{1}", text, oPCE.ProgressText);
				};
			}
			bResult = oseExporter.ExportSessions(sExportFormat, oSessions, dictOptions, ehPCEA);
			oseExporter.Dispose();
		}
		catch (Exception eX)
		{
			LogAddonException(eX, "Exporter for " + sExportFormat + " failed.");
			bResult = false;
		}
		return bResult;
	}

	/// <summary>
	/// Calls a Fiddler Session Importer and returns the list of loaded Sessions.
	/// </summary>
	/// <param name="sImportFormat">String naming the Import format, e.g. HTTPArchive</param>
	/// <param name="bAddToSessionList">Should sessions be added to WebSessions list? (Not meaningful for FiddlerCore)</param>
	/// <param name="dictOptions">Dictionary of Options to pass to the Transcoder</param>
	/// <param name="ehPCEA">Your callback event handler, or NULL to allow Fiddler to handle</param>
	/// <param name="passwordCallback">Callback that is used to request passwords from the host if needed</param>
	/// <returns>Loaded Session[], or null on Failure</returns>
	public static Session[] DoImport(string sImportFormat, bool bAddToSessionList, Dictionary<string, object> dictOptions, EventHandler<ProgressCallbackEventArgs> ehPCEA, GetPasswordDelegate passwordCallback = null)
	{
		if (string.IsNullOrEmpty(sImportFormat))
		{
			return null;
		}
		TranscoderTuple ttImport = oTranscoders.GetImporter(sImportFormat);
		if (ttImport == null)
		{
			return null;
		}
		Session[] oSessions = null;
		try
		{
			ISessionImporter oseImporter = (ISessionImporter)Activator.CreateInstance(ttImport.typeFormatter);
			if (ehPCEA == null)
			{
				ehPCEA = delegate(object sender, ProgressCallbackEventArgs oPCE)
				{
					string text = ((oPCE.PercentComplete > 0) ? ("Import is " + oPCE.PercentComplete + "% complete; ") : string.Empty);
					Log.LogFormat("{0}{1}", text, oPCE.ProgressText);
				};
			}
			bool alreadyImported = false;
			if (oseImporter is IPasswordProtectedSessionImporter passwordProtectedSessionImporter)
			{
				oSessions = passwordProtectedSessionImporter.ImportSessions(sImportFormat, dictOptions, ehPCEA, passwordCallback);
				alreadyImported = true;
			}
			if (!alreadyImported)
			{
				oSessions = oseImporter.ImportSessions(sImportFormat, dictOptions, ehPCEA);
			}
			oseImporter.Dispose();
			if (oSessions == null)
			{
				return null;
			}
			Session[] array = oSessions;
			foreach (Session session in array)
			{
				session.SetBitFlag(SessionFlags.ImportedFromOtherTool, b: true);
				if (session.HTTPMethodIs("CONNECT"))
				{
					session.isTunnel = true;
				}
				if (session.id == 0)
				{
					session._AssignID();
				}
				session.RaiseSessionFieldChanged();
			}
		}
		catch (Exception eX)
		{
			LogAddonException(eX, "Importer for " + sImportFormat + " failed.");
			oSessions = null;
		}
		return oSessions;
	}

	/// <summary>
	/// Reset the SessionID counter to 0. This method can lead to confusing UI, so call sparingly.
	/// </summary>
	[CodeDescription("Reset the SessionID counter to 0. This method can lead to confusing UI, so call sparingly.")]
	public static void ResetSessionCounter()
	{
		Session.ResetSessionCounter();
	}

	/// <summary>
	/// Show the user a message when an HTTP Error was encountered
	/// </summary>
	/// <param name="oSession">Session with error</param>
	/// <param name="bPoisonClientConnection">Set to true to prevent pooling/reuse of client connection</param>
	/// <param name="flagViolation">The SessionFlag which should be set to log this violation</param>
	/// <param name="bPoisonServerConnection">Set to true to prevent pooling/reuse of server connection</param>
	/// <param name="sMessage">Information about the problem</param>
	internal static void HandleHTTPError(Session oSession, SessionFlags flagViolation, bool bPoisonClientConnection, bool bPoisonServerConnection, string sMessage)
	{
		oSession.EnsureID();
		if (bPoisonClientConnection)
		{
			oSession.PoisonClientPipe();
		}
		if (bPoisonServerConnection)
		{
			oSession.PoisonServerPipe();
		}
		oSession.SetBitFlag(flagViolation, b: true);
		oSession["ui-backcolor"] = "LightYellow";
		Log.LogFormat("{0} - [#{1}] {2}", "Fiddler.Network.ProtocolViolation", oSession.id.ToString(), sMessage);
		sMessage = "[ProtocolViolation] " + sMessage;
		if (oSession["x-HTTPProtocol-Violation"] == null || !oSession["x-HTTPProtocol-Violation"].Contains(sMessage))
		{
			oSession["x-HTTPProtocol-Violation"] += sMessage;
		}
	}

	internal static void DebugSpew(string sMessage)
	{
		if (!CONFIG.bDebugSpew)
		{
		}
	}

	internal static void DebugSpew(string sMessage, params object[] args)
	{
		if (!CONFIG.bDebugSpew)
		{
		}
	}

	static FiddlerApplication()
	{
		oTelemetry = null;
		sazProvider = new SazProvider();
		_Log = new Logger(bQueueStartup: false);
		Janitor = new PeriodicWorker();
		oTranscoders = new FiddlerTranscoders();
		slLeakedFiles = new List<string>();
		_SetXceedLicenseKeys();
		try
		{
			Process oMe = Process.GetCurrentProcess();
			iPID = oMe.Id;
			sProcessInfo = $"{oMe.ProcessName.ToLower()}:{iPID}";
			oMe.Dispose();
		}
		catch (Exception)
		{
		}
		platformExtensions = PlatformExtensionsFactory.Instance.CreatePlatformExtensions();
	}

	/// <summary>
	/// We really don't want this method to get inlined, because that would cause the Xceed DLLs to get loaded in the Main() function instead
	/// of when _SetXceedLicenseKeys is called; that, in turn, would delay the SplashScreen.
	/// </summary>
	[MethodImpl(MethodImplOptions.NoInlining)]
	internal static void _SetXceedLicenseKeys()
	{
	}

	/// <summary>
	/// Used to track errors with addons.
	/// </summary>
	/// <param name="eX"></param>
	/// <param name="sTitle"></param>
	internal static void LogAddonException(Exception eX, string sTitle)
	{
		if (Prefs.GetBoolPref("fiddler.debug.extensions.showerrors", bDefault: false) || Prefs.GetBoolPref("fiddler.debug.extensions.verbose", bDefault: false))
		{
			Log.LogFormat("!Exception from Extension: {0}", FiddlerCore.Utilities.Utilities.DescribeException(eX));
		}
	}

	/// <summary>
	/// Record that a temporary file was created and handed to an external tool. We'll do our best to delete this file on exit.
	/// </summary>
	/// <param name="sTempFile">The filename of the file to be deleted</param>
	public static void LogLeakedFile(string sTempFile)
	{
		lock (slLeakedFiles)
		{
			slLeakedFiles.Add(sTempFile);
		}
	}

	/// <summary>
	/// Clean up any Temporary files that were created
	/// </summary>
	internal static void WipeLeakedFiles()
	{
		try
		{
			if (slLeakedFiles.Count < 1)
			{
				return;
			}
			lock (slLeakedFiles)
			{
				foreach (string sFilename in slLeakedFiles)
				{
					try
					{
						File.Delete(sFilename);
					}
					catch (Exception)
					{
					}
				}
				slLeakedFiles.Clear();
			}
		}
		catch (Exception)
		{
		}
	}

	internal static void DoAfterSocketConnect(Session oSession, Socket sockServer)
	{
		EventHandler<ConnectionEventArgs> oHandler = FiddlerApplication.AfterSocketConnect;
		if (oHandler != null)
		{
			ConnectionEventArgs oEA = new ConnectionEventArgs(oSession, sockServer);
			oHandler(oSession, oEA);
		}
	}

	internal static void DoAfterSocketAccept(Session oSession, Socket sockClient)
	{
		EventHandler<ConnectionEventArgs> oHandler = FiddlerApplication.AfterSocketAccept;
		if (oHandler != null)
		{
			ConnectionEventArgs oEA = new ConnectionEventArgs(oSession, sockClient);
			oHandler(oSession, oEA);
		}
	}

	/// <summary>
	/// Does this Fiddler instance support the specified feature?
	/// </summary>
	/// <param name="sFeatureName">Feature name (e.g. "bzip2")</param>
	/// <returns>TRUE if the specified feature is supported; false otherwise</returns>
	public static bool Supports(string sFeatureName)
	{
		switch (sFeatureName)
		{
		case "bzip2":
			return false;
		case "xpress":
			return Utilities.IsWin8OrLater();
		case "br":
			try
			{
				return File.Exists(CONFIG.GetPath("Tools") + "brotli.exe");
			}
			catch (Exception)
			{
				return false;
			}
		default:
			return false;
		}
	}

	internal static void AttachToPlatformExtensionsEvents()
	{
		platformExtensions.DebugSpew += OnDebugSpew;
		platformExtensions.Error += OnError;
		platformExtensions.Log += OnLog;
	}

	internal static void DetachFromPlatformExtensionsEvents()
	{
		platformExtensions.DebugSpew -= OnDebugSpew;
		platformExtensions.Error -= OnError;
		platformExtensions.Log -= OnLog;
	}

	private static void OnDebugSpew(object sender, MessageEventArgs args)
	{
		DebugSpew(args.Message);
	}

	private static void OnError(object sender, MessageEventArgs args)
	{
		Log.LogString(args.Message);
	}

	private static void OnLog(object sender, MessageEventArgs args)
	{
		Log.LogString(args.Message);
	}

	private static void TrackAnalyticsOnStartup()
	{
		InitializeTelemetry();
		oTelemetry.TrackFeature(null, "FiddlerCoreStartup");
		oTelemetry.TrackMachineInformation(Utilities.GetOSVerString(), DotNetVersionRecognizer.GetHighestVersionInstalledForCurrentClr(), Utilities.GetProcessorString());
		oTelemetry.TrackApplicationInformation();
		ThreadPool.QueueUserWorkItem(delegate
		{
			oTelemetry.Stop();
		});
	}
}
